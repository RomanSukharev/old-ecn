// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package public_models

import (
	"fmt"
	"io"
	"strconv"
	"time"
)

type Node interface {
	IsNode()
	GetID() string
}

type ComplexConnection struct {
	TotalCount int            `json:"totalCount"`
	Edges      []*ComplexEdge `json:"edges"`
	Nodes      []*Complex     `json:"nodes"`
	PageInfo   *PageInfo      `json:"pageInfo"`
}

type ComplexEdge struct {
	Node   *Complex `json:"node"`
	Cursor string   `json:"cursor"`
}

type ComplexHouseConnection struct {
	TotalCount int                 `json:"totalCount"`
	Edges      []*ComplexHouseEdge `json:"edges"`
	Nodes      []*ComplexHouse     `json:"nodes"`
	PageInfo   *PageInfo           `json:"pageInfo"`
}

type ComplexHouseEdge struct {
	Node   *ComplexHouse `json:"node"`
	Cursor string        `json:"cursor"`
}

type ComplexHouseFilter struct {
	ComplexID *string `json:"complexID,omitempty"`
}

type ContentBlock struct {
	Type      ContentBlockType       `json:"type"`
	Data      map[string]interface{} `json:"data"`
	IsVisible bool                   `json:"isVisible"`
}

type ContentBlockInput struct {
	Type      ContentBlockType       `json:"type"`
	Data      map[string]interface{} `json:"data"`
	IsVisible bool                   `json:"isVisible"`
}

type DeveloperConnection struct {
	TotalCount int              `json:"totalCount"`
	Edges      []*DeveloperEdge `json:"edges"`
	Nodes      []*Developer     `json:"nodes"`
	PageInfo   *PageInfo        `json:"pageInfo"`
}

type DeveloperEdge struct {
	Node   *Developer `json:"node"`
	Cursor string     `json:"cursor"`
}

type EmployeeConnection struct {
	TotalCount int             `json:"totalCount"`
	Edges      []*EmployeeEdge `json:"edges"`
	Nodes      []*Employee     `json:"nodes"`
	PageInfo   *PageInfo       `json:"pageInfo"`
}

type EmployeeEdge struct {
	Node   *Employee `json:"node"`
	Cursor string    `json:"cursor"`
}

type Mutation struct {
}

type Page struct {
	ID            string                `json:"id"`
	URL           string                `json:"url"`
	Title         string                `json:"title"`
	Description   string                `json:"description"`
	ContentBlocks []*ContentBlock       `json:"contentBlocks"`
	Status        PublicationStatusEnum `json:"status"`
	CreatedAt     time.Time             `json:"createdAt"`
	UpdatedAt     time.Time             `json:"updatedAt"`
}

type PageConnection struct {
	TotalCount int         `json:"totalCount"`
	Edges      []*PageEdge `json:"edges"`
	Nodes      []*Page     `json:"nodes"`
	PageInfo   *PageInfo   `json:"pageInfo"`
}

type PageEdge struct {
	Node   *Page  `json:"node"`
	Cursor string `json:"cursor"`
}

type PageInfo struct {
	StartCursor     *string `json:"startCursor,omitempty"`
	EndCursor       *string `json:"endCursor,omitempty"`
	HasNextPage     bool    `json:"hasNextPage"`
	HasPreviousPage bool    `json:"hasPreviousPage"`
}

type PaginationInput struct {
	First  *int    `json:"first,omitempty"`
	Last   *int    `json:"last,omitempty"`
	After  *string `json:"after,omitempty"`
	Before *string `json:"before,omitempty"`
}

type PropertyConnection struct {
	TotalCount int             `json:"totalCount"`
	Edges      []*PropertyEdge `json:"edges"`
	Nodes      []*Property     `json:"nodes"`
	PageInfo   *PageInfo       `json:"pageInfo"`
}

type PropertyEdge struct {
	Node   *Property `json:"node"`
	Cursor string    `json:"cursor"`
}

type PropertyFilter struct {
	Deal             *DealEnum            `json:"deal,omitempty"`
	Type             *PropertyTypeEnum    `json:"type,omitempty"`
	SubType          *PropertySubTypeEnum `json:"subType,omitempty"`
	FromDeveloper    *bool                `json:"fromDeveloper,omitempty"`
	ComplexID        *string              `json:"complexID,omitempty"`
	ComplexHouseID   *string              `json:"complexHouseID,omitempty"`
	VillageID        *string              `json:"villageID,omitempty"`
	IsHot            *bool                `json:"isHot,omitempty"`
	MinRooms         *float64             `json:"minRooms,omitempty"`
	MaxRooms         *float64             `json:"maxRooms,omitempty"`
	MinPrice         *float64             `json:"minPrice,omitempty"`
	MaxPrice         *float64             `json:"maxPrice,omitempty"`
	MinPricePerMeter *float64             `json:"minPricePerMeter,omitempty"`
	MaxPricePerMeter *float64             `json:"maxPricePerMeter,omitempty"`
	MinPricePerAr    *float64             `json:"minPricePerAr,omitempty"`
	MaxPricePerAr    *float64             `json:"maxPricePerAr,omitempty"`
	MinArea          *float64             `json:"minArea,omitempty"`
	MaxArea          *float64             `json:"maxArea,omitempty"`
	MinLandArea      *float64             `json:"minLandArea,omitempty"`
	MaxLandArea      *float64             `json:"maxLandArea,omitempty"`
	IsReady          *bool                `json:"isReady,omitempty"`
	InCity           *bool                `json:"inCity,omitempty"`
	MinCityDistance  *int                 `json:"minCityDistance,omitempty"`
	MaxCityDistance  *int                 `json:"maxCityDistance,omitempty"`
	WithPhotos       *bool                `json:"withPhotos,omitempty"`
}

type Query struct {
}

type Readiness struct {
	Year    *int `json:"year,omitempty"`
	Quarter *int `json:"quarter,omitempty"`
}

// Отзыв
type Review struct {
	// Уникальный идентификатор
	ID string `json:"id"`
	// Сотрудник
	Employee *Employee `json:"employee,omitempty"`
	// Текст отзыва
	Text string `json:"text"`
	// Имя автора
	AuthorName string `json:"authorName"`
	// Номер телефона автора
	AuthorPhone string `json:"authorPhone"`
	// Статус отзыва
	Status ReviewStatusEnum `json:"status"`
	// Дата и время создания
	CreatedAt time.Time `json:"createdAt"`
	// Дата и время обновления
	UpdatedAt time.Time `json:"updatedAt"`
}

type ReviewConnection struct {
	TotalCount int           `json:"totalCount"`
	Edges      []*ReviewEdge `json:"edges"`
	Nodes      []*Review     `json:"nodes"`
	PageInfo   *PageInfo     `json:"pageInfo"`
}

type ReviewEdge struct {
	Node   *Review `json:"node"`
	Cursor string  `json:"cursor"`
}

// Расширенный фильтр по отзывам
type ReviewsFilterInput struct {
	// Набор статусов для фильтрации
	Statuses []ReviewStatusEnum `json:"statuses,omitempty"`
	// Набор идентфикаторов сотрудников для фильтрации
	Employees []string `json:"employees,omitempty"`
}

// Режим сортировки для списочных методов
type Sort struct {
	// Поле, по которому производится сортировка
	Field *string `json:"field,omitempty"`
	// Направление сортировки по выбранному полю
	Direction *SortDirection `json:"direction,omitempty"`
}

type StoryConnection struct {
	TotalCount int          `json:"totalCount"`
	Edges      []*StoryEdge `json:"edges"`
	Nodes      []*Story     `json:"nodes"`
	PageInfo   *PageInfo    `json:"pageInfo"`
}

type StoryEdge struct {
	Node   *Story `json:"node"`
	Cursor string `json:"cursor"`
}

type VacancyConnection struct {
	TotalCount int            `json:"totalCount"`
	Edges      []*VacancyEdge `json:"edges"`
	Nodes      []*Vacancy     `json:"nodes"`
	PageInfo   *PageInfo      `json:"pageInfo"`
}

type VacancyEdge struct {
	Node   *Vacancy `json:"node"`
	Cursor string   `json:"cursor"`
}

// Отклик на вакансию
type VacancyRequestInput struct {
	// Связанная вакансия
	Vacancy string `json:"vacancy"`
	// Имя соискателя
	Name string `json:"name"`
	// Сопроводительное письмо
	Letter string `json:"letter"`
	// Вложения
	Attachments []*DocumentInput `json:"attachments,omitempty"`
}

type VillageConnection struct {
	TotalCount int            `json:"totalCount"`
	Edges      []*VillageEdge `json:"edges"`
	Nodes      []*Village     `json:"nodes"`
	PageInfo   *PageInfo      `json:"pageInfo"`
}

type VillageEdge struct {
	Node   *Village `json:"node"`
	Cursor string   `json:"cursor"`
}

type CommercialUsageEnum string

const (
	CommercialUsageEnumRetail     CommercialUsageEnum = "RETAIL"
	CommercialUsageEnumOffice     CommercialUsageEnum = "OFFICE"
	CommercialUsageEnumFreeUsage  CommercialUsageEnum = "FREE_USAGE"
	CommercialUsageEnumBase       CommercialUsageEnum = "BASE"
	CommercialUsageEnumBusiness   CommercialUsageEnum = "BUSINESS"
	CommercialUsageEnumProduction CommercialUsageEnum = "PRODUCTION"
	CommercialUsageEnumParking    CommercialUsageEnum = "PARKING"
	CommercialUsageEnumWarehouse  CommercialUsageEnum = "WAREHOUSE"
)

var AllCommercialUsageEnum = []CommercialUsageEnum{
	CommercialUsageEnumRetail,
	CommercialUsageEnumOffice,
	CommercialUsageEnumFreeUsage,
	CommercialUsageEnumBase,
	CommercialUsageEnumBusiness,
	CommercialUsageEnumProduction,
	CommercialUsageEnumParking,
	CommercialUsageEnumWarehouse,
}

func (e CommercialUsageEnum) IsValid() bool {
	switch e {
	case CommercialUsageEnumRetail, CommercialUsageEnumOffice, CommercialUsageEnumFreeUsage, CommercialUsageEnumBase, CommercialUsageEnumBusiness, CommercialUsageEnumProduction, CommercialUsageEnumParking, CommercialUsageEnumWarehouse:
		return true
	}
	return false
}

func (e CommercialUsageEnum) String() string {
	return string(e)
}

func (e *CommercialUsageEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CommercialUsageEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CommercialUsageEnum", str)
	}
	return nil
}

func (e CommercialUsageEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ContentBlockType string

const (
	ContentBlockTypeText      ContentBlockType = "TEXT"
	ContentBlockTypeCite      ContentBlockType = "CITE"
	ContentBlockTypeFiles     ContentBlockType = "FILES"
	ContentBlockTypeYoutube   ContentBlockType = "YOUTUBE"
	ContentBlockTypeImages    ContentBlockType = "IMAGES"
	ContentBlockTypeAccordion ContentBlockType = "ACCORDION"
	ContentBlockTypeSpecial   ContentBlockType = "SPECIAL"
)

var AllContentBlockType = []ContentBlockType{
	ContentBlockTypeText,
	ContentBlockTypeCite,
	ContentBlockTypeFiles,
	ContentBlockTypeYoutube,
	ContentBlockTypeImages,
	ContentBlockTypeAccordion,
	ContentBlockTypeSpecial,
}

func (e ContentBlockType) IsValid() bool {
	switch e {
	case ContentBlockTypeText, ContentBlockTypeCite, ContentBlockTypeFiles, ContentBlockTypeYoutube, ContentBlockTypeImages, ContentBlockTypeAccordion, ContentBlockTypeSpecial:
		return true
	}
	return false
}

func (e ContentBlockType) String() string {
	return string(e)
}

func (e *ContentBlockType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ContentBlockType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ContentBlockType", str)
	}
	return nil
}

func (e ContentBlockType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type DealEnum string

const (
	DealEnumSell DealEnum = "SELL"
	DealEnumRent DealEnum = "RENT"
)

var AllDealEnum = []DealEnum{
	DealEnumSell,
	DealEnumRent,
}

func (e DealEnum) IsValid() bool {
	switch e {
	case DealEnumSell, DealEnumRent:
		return true
	}
	return false
}

func (e DealEnum) String() string {
	return string(e)
}

func (e *DealEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DealEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DealEnum", str)
	}
	return nil
}

func (e DealEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ImagePreset string

const (
	ImagePresetStaffEmployeeAvatar      ImagePreset = "STAFF_EMPLOYEE_AVATAR"
	ImagePresetStaffEmployeePublicImage ImagePreset = "STAFF_EMPLOYEE_PUBLIC_IMAGE"
	ImagePresetContentKbArticleCover    ImagePreset = "CONTENT_KB_ARTICLE_COVER"
	ImagePresetContentSiteStoryCover    ImagePreset = "CONTENT_SITE_STORY_COVER"
	ImagePresetContentSiteStoryPhoto    ImagePreset = "CONTENT_SITE_STORY_PHOTO"
	ImagePresetEstatePropertyPhoto      ImagePreset = "ESTATE_PROPERTY_PHOTO"
	ImagePresetEstateComplexPhoto       ImagePreset = "ESTATE_COMPLEX_PHOTO"
)

var AllImagePreset = []ImagePreset{
	ImagePresetStaffEmployeeAvatar,
	ImagePresetStaffEmployeePublicImage,
	ImagePresetContentKbArticleCover,
	ImagePresetContentSiteStoryCover,
	ImagePresetContentSiteStoryPhoto,
	ImagePresetEstatePropertyPhoto,
	ImagePresetEstateComplexPhoto,
}

func (e ImagePreset) IsValid() bool {
	switch e {
	case ImagePresetStaffEmployeeAvatar, ImagePresetStaffEmployeePublicImage, ImagePresetContentKbArticleCover, ImagePresetContentSiteStoryCover, ImagePresetContentSiteStoryPhoto, ImagePresetEstatePropertyPhoto, ImagePresetEstateComplexPhoto:
		return true
	}
	return false
}

func (e ImagePreset) String() string {
	return string(e)
}

func (e *ImagePreset) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ImagePreset(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ImagePreset", str)
	}
	return nil
}

func (e ImagePreset) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type PropertySourceEnum string

const (
	PropertySourceEnumAvito           PropertySourceEnum = "AVITO"
	PropertySourceEnumYoula           PropertySourceEnum = "YOULA"
	PropertySourceEnumCian            PropertySourceEnum = "CIAN"
	PropertySourceEnumDomclick        PropertySourceEnum = "DOMCLICK"
	PropertySourceEnumYandex          PropertySourceEnum = "YANDEX"
	PropertySourceEnumOtherAggregator PropertySourceEnum = "OTHER_AGGREGATOR"
	PropertySourceEnumRecommendation  PropertySourceEnum = "RECOMMENDATION"
	PropertySourceEnumReturnedClient  PropertySourceEnum = "RETURNED_CLIENT"
	PropertySourceEnumLists           PropertySourceEnum = "LISTS"
	PropertySourceEnumSelection       PropertySourceEnum = "SELECTION"
	PropertySourceEnumOther           PropertySourceEnum = "OTHER"
)

var AllPropertySourceEnum = []PropertySourceEnum{
	PropertySourceEnumAvito,
	PropertySourceEnumYoula,
	PropertySourceEnumCian,
	PropertySourceEnumDomclick,
	PropertySourceEnumYandex,
	PropertySourceEnumOtherAggregator,
	PropertySourceEnumRecommendation,
	PropertySourceEnumReturnedClient,
	PropertySourceEnumLists,
	PropertySourceEnumSelection,
	PropertySourceEnumOther,
}

func (e PropertySourceEnum) IsValid() bool {
	switch e {
	case PropertySourceEnumAvito, PropertySourceEnumYoula, PropertySourceEnumCian, PropertySourceEnumDomclick, PropertySourceEnumYandex, PropertySourceEnumOtherAggregator, PropertySourceEnumRecommendation, PropertySourceEnumReturnedClient, PropertySourceEnumLists, PropertySourceEnumSelection, PropertySourceEnumOther:
		return true
	}
	return false
}

func (e PropertySourceEnum) String() string {
	return string(e)
}

func (e *PropertySourceEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PropertySourceEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PropertySourceEnum", str)
	}
	return nil
}

func (e PropertySourceEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type PropertyStatusEnum string

const (
	PropertyStatusEnumPublished    PropertyStatusEnum = "PUBLISHED"
	PropertyStatusEnumUnpublished  PropertyStatusEnum = "UNPUBLISHED"
	PropertyStatusEnumOnModeration PropertyStatusEnum = "ON_MODERATION"
	PropertyStatusEnumArchived     PropertyStatusEnum = "ARCHIVED"
	PropertyStatusEnumTrash        PropertyStatusEnum = "TRASH"
)

var AllPropertyStatusEnum = []PropertyStatusEnum{
	PropertyStatusEnumPublished,
	PropertyStatusEnumUnpublished,
	PropertyStatusEnumOnModeration,
	PropertyStatusEnumArchived,
	PropertyStatusEnumTrash,
}

func (e PropertyStatusEnum) IsValid() bool {
	switch e {
	case PropertyStatusEnumPublished, PropertyStatusEnumUnpublished, PropertyStatusEnumOnModeration, PropertyStatusEnumArchived, PropertyStatusEnumTrash:
		return true
	}
	return false
}

func (e PropertyStatusEnum) String() string {
	return string(e)
}

func (e *PropertyStatusEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PropertyStatusEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PropertyStatusEnum", str)
	}
	return nil
}

func (e PropertyStatusEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type PropertySubTypeEnum string

const (
	PropertySubTypeEnumFlat        PropertySubTypeEnum = "FLAT"
	PropertySubTypeEnumRoom        PropertySubTypeEnum = "ROOM"
	PropertySubTypeEnumApartment   PropertySubTypeEnum = "APARTMENT"
	PropertySubTypeEnumStudio      PropertySubTypeEnum = "STUDIO"
	PropertySubTypeEnumLand        PropertySubTypeEnum = "LAND"
	PropertySubTypeEnumHouse       PropertySubTypeEnum = "HOUSE"
	PropertySubTypeEnumTownhouse   PropertySubTypeEnum = "TOWNHOUSE"
	PropertySubTypeEnumSummerHouse PropertySubTypeEnum = "SUMMER_HOUSE"
	PropertySubTypeEnumGarage      PropertySubTypeEnum = "GARAGE"
	PropertySubTypeEnumParking     PropertySubTypeEnum = "PARKING"
)

var AllPropertySubTypeEnum = []PropertySubTypeEnum{
	PropertySubTypeEnumFlat,
	PropertySubTypeEnumRoom,
	PropertySubTypeEnumApartment,
	PropertySubTypeEnumStudio,
	PropertySubTypeEnumLand,
	PropertySubTypeEnumHouse,
	PropertySubTypeEnumTownhouse,
	PropertySubTypeEnumSummerHouse,
	PropertySubTypeEnumGarage,
	PropertySubTypeEnumParking,
}

func (e PropertySubTypeEnum) IsValid() bool {
	switch e {
	case PropertySubTypeEnumFlat, PropertySubTypeEnumRoom, PropertySubTypeEnumApartment, PropertySubTypeEnumStudio, PropertySubTypeEnumLand, PropertySubTypeEnumHouse, PropertySubTypeEnumTownhouse, PropertySubTypeEnumSummerHouse, PropertySubTypeEnumGarage, PropertySubTypeEnumParking:
		return true
	}
	return false
}

func (e PropertySubTypeEnum) String() string {
	return string(e)
}

func (e *PropertySubTypeEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PropertySubTypeEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PropertySubTypeEnum", str)
	}
	return nil
}

func (e PropertySubTypeEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type PropertyTypeEnum string

const (
	PropertyTypeEnumUsed       PropertyTypeEnum = "USED"
	PropertyTypeEnumNew        PropertyTypeEnum = "NEW"
	PropertyTypeEnumVillage    PropertyTypeEnum = "VILLAGE"
	PropertyTypeEnumSuburban   PropertyTypeEnum = "SUBURBAN"
	PropertyTypeEnumCommercial PropertyTypeEnum = "COMMERCIAL"
)

var AllPropertyTypeEnum = []PropertyTypeEnum{
	PropertyTypeEnumUsed,
	PropertyTypeEnumNew,
	PropertyTypeEnumVillage,
	PropertyTypeEnumSuburban,
	PropertyTypeEnumCommercial,
}

func (e PropertyTypeEnum) IsValid() bool {
	switch e {
	case PropertyTypeEnumUsed, PropertyTypeEnumNew, PropertyTypeEnumVillage, PropertyTypeEnumSuburban, PropertyTypeEnumCommercial:
		return true
	}
	return false
}

func (e PropertyTypeEnum) String() string {
	return string(e)
}

func (e *PropertyTypeEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PropertyTypeEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PropertyTypeEnum", str)
	}
	return nil
}

func (e PropertyTypeEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Статус публикации
type PublicationStatusEnum string

const (
	// Запись опубликована
	PublicationStatusEnumPublished PublicationStatusEnum = "PUBLISHED"
	// Черновик
	PublicationStatusEnumDraft PublicationStatusEnum = "DRAFT"
	// Запись снята с публикации
	PublicationStatusEnumUnpublished PublicationStatusEnum = "UNPUBLISHED"
)

var AllPublicationStatusEnum = []PublicationStatusEnum{
	PublicationStatusEnumPublished,
	PublicationStatusEnumDraft,
	PublicationStatusEnumUnpublished,
}

func (e PublicationStatusEnum) IsValid() bool {
	switch e {
	case PublicationStatusEnumPublished, PublicationStatusEnumDraft, PublicationStatusEnumUnpublished:
		return true
	}
	return false
}

func (e PublicationStatusEnum) String() string {
	return string(e)
}

func (e *PublicationStatusEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PublicationStatusEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PublicationStatusEnum", str)
	}
	return nil
}

func (e PublicationStatusEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type QuarterEnum string

const (
	QuarterEnumI   QuarterEnum = "I"
	QuarterEnumIi  QuarterEnum = "II"
	QuarterEnumIii QuarterEnum = "III"
	QuarterEnumIv  QuarterEnum = "IV"
)

var AllQuarterEnum = []QuarterEnum{
	QuarterEnumI,
	QuarterEnumIi,
	QuarterEnumIii,
	QuarterEnumIv,
}

func (e QuarterEnum) IsValid() bool {
	switch e {
	case QuarterEnumI, QuarterEnumIi, QuarterEnumIii, QuarterEnumIv:
		return true
	}
	return false
}

func (e QuarterEnum) String() string {
	return string(e)
}

func (e *QuarterEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = QuarterEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid QuarterEnum", str)
	}
	return nil
}

func (e QuarterEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type RehabTypeEnum string

const (
	RehabTypeEnumNone      RehabTypeEnum = "NONE"
	RehabTypeEnumDraft     RehabTypeEnum = "DRAFT"
	RehabTypeEnumDeveloper RehabTypeEnum = "DEVELOPER"
	RehabTypeEnumDesign    RehabTypeEnum = "DESIGN"
	RehabTypeEnumClean     RehabTypeEnum = "CLEAN"
)

var AllRehabTypeEnum = []RehabTypeEnum{
	RehabTypeEnumNone,
	RehabTypeEnumDraft,
	RehabTypeEnumDeveloper,
	RehabTypeEnumDesign,
	RehabTypeEnumClean,
}

func (e RehabTypeEnum) IsValid() bool {
	switch e {
	case RehabTypeEnumNone, RehabTypeEnumDraft, RehabTypeEnumDeveloper, RehabTypeEnumDesign, RehabTypeEnumClean:
		return true
	}
	return false
}

func (e RehabTypeEnum) String() string {
	return string(e)
}

func (e *RehabTypeEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RehabTypeEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RehabTypeEnum", str)
	}
	return nil
}

func (e RehabTypeEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Статус отзыва
type ReviewStatusEnum string

const (
	// Новый
	ReviewStatusEnumNew ReviewStatusEnum = "NEW"
	// Подтверждён
	ReviewStatusEnumApproved ReviewStatusEnum = "APPROVED"
	// Отклонён
	ReviewStatusEnumDeclined ReviewStatusEnum = "DECLINED"
)

var AllReviewStatusEnum = []ReviewStatusEnum{
	ReviewStatusEnumNew,
	ReviewStatusEnumApproved,
	ReviewStatusEnumDeclined,
}

func (e ReviewStatusEnum) IsValid() bool {
	switch e {
	case ReviewStatusEnumNew, ReviewStatusEnumApproved, ReviewStatusEnumDeclined:
		return true
	}
	return false
}

func (e ReviewStatusEnum) String() string {
	return string(e)
}

func (e *ReviewStatusEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ReviewStatusEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ReviewStatusEnum", str)
	}
	return nil
}

func (e ReviewStatusEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Направления сортировки
type SortDirection string

const (
	// По возрастанию
	SortDirectionAsc SortDirection = "ASC"
	// По убыванию
	SortDirectionDesc SortDirection = "DESC"
)

var AllSortDirection = []SortDirection{
	SortDirectionAsc,
	SortDirectionDesc,
}

func (e SortDirection) IsValid() bool {
	switch e {
	case SortDirectionAsc, SortDirectionDesc:
		return true
	}
	return false
}

func (e SortDirection) String() string {
	return string(e)
}

func (e *SortDirection) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SortDirection(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SortDirection", str)
	}
	return nil
}

func (e SortDirection) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Категория новости
type StoryCategoryEnum string

const (
	// Новости
	StoryCategoryEnumNews StoryCategoryEnum = "NEWS"
	// Недвижимость
	StoryCategoryEnumEstate StoryCategoryEnum = "ESTATE"
	// Жизнь компании
	StoryCategoryEnumCompany StoryCategoryEnum = "COMPANY"
)

var AllStoryCategoryEnum = []StoryCategoryEnum{
	StoryCategoryEnumNews,
	StoryCategoryEnumEstate,
	StoryCategoryEnumCompany,
}

func (e StoryCategoryEnum) IsValid() bool {
	switch e {
	case StoryCategoryEnumNews, StoryCategoryEnumEstate, StoryCategoryEnumCompany:
		return true
	}
	return false
}

func (e StoryCategoryEnum) String() string {
	return string(e)
}

func (e *StoryCategoryEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = StoryCategoryEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid StoryCategoryEnum", str)
	}
	return nil
}

func (e StoryCategoryEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ToiletTypeEnum string

const (
	ToiletTypeEnumUnited   ToiletTypeEnum = "UNITED"
	ToiletTypeEnumSplitted ToiletTypeEnum = "SPLITTED"
)

var AllToiletTypeEnum = []ToiletTypeEnum{
	ToiletTypeEnumUnited,
	ToiletTypeEnumSplitted,
}

func (e ToiletTypeEnum) IsValid() bool {
	switch e {
	case ToiletTypeEnumUnited, ToiletTypeEnumSplitted:
		return true
	}
	return false
}

func (e ToiletTypeEnum) String() string {
	return string(e)
}

func (e *ToiletTypeEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ToiletTypeEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ToiletTypeEnum", str)
	}
	return nil
}

func (e ToiletTypeEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// График работы по вакансии
type VacancyScheduleEnum string

const (
	// Полный день
	VacancyScheduleEnumFullTime VacancyScheduleEnum = "FULL_TIME"
	// Частичная занятость
	VacancyScheduleEnumPartTime VacancyScheduleEnum = "PART_TIME"
)

var AllVacancyScheduleEnum = []VacancyScheduleEnum{
	VacancyScheduleEnumFullTime,
	VacancyScheduleEnumPartTime,
}

func (e VacancyScheduleEnum) IsValid() bool {
	switch e {
	case VacancyScheduleEnumFullTime, VacancyScheduleEnumPartTime:
		return true
	}
	return false
}

func (e VacancyScheduleEnum) String() string {
	return string(e)
}

func (e *VacancyScheduleEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = VacancyScheduleEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid VacancyScheduleEnum", str)
	}
	return nil
}

func (e VacancyScheduleEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
