package public_resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.47

import (
	"context"

	public_gateway "github.com/pinks-agency/ecn/server/internal/public-facade/gateway"
	public_models "github.com/pinks-agency/ecn/server/internal/public-facade/models"
	estate_entity "github.com/pinks-agency/ecn/server/pkg/estate/entity"
)

// Complex is the resolver for the complex field.
func (r *propertyResolver) Complex(ctx context.Context, obj *public_models.Property) (*public_models.Complex, error) {
	if obj.ComplexID != nil {
		data, err := r.EstateService.GetComplexByID(ctx, *obj.ComplexID)
		if err != nil {
			return nil, err
		}

		return new(public_models.Complex).FromEntity(data), nil
	}

	return nil, nil
}

// ComplexHouse is the resolver for the complexHouse field.
func (r *propertyResolver) ComplexHouse(ctx context.Context, obj *public_models.Property) (*public_models.ComplexHouse, error) {
	if obj.ComplexHouseID != nil {
		data, err := r.EstateService.GetComplexHouseByID(ctx, *obj.ComplexHouseID)
		if err != nil {
			return nil, err
		}

		return new(public_models.ComplexHouse).FromEntity(data), nil
	}

	return nil, nil
}

// Village is the resolver for the village field.
func (r *propertyResolver) Village(ctx context.Context, obj *public_models.Property) (*public_models.Village, error) {
	if obj.VillageID != nil {
		data, err := r.EstateService.GetVillageByID(ctx, *obj.VillageID)
		if err != nil {
			return nil, err
		}

		return new(public_models.Village).FromEntity(data), nil
	}

	return nil, nil
}

// Documents is the resolver for the documents field.
func (r *propertyResolver) Documents(ctx context.Context, obj *public_models.Property) ([]*public_models.Document, error) {
	result := make([]*public_models.Document, 0, len(obj.DocumentIDs))

	for _, v := range obj.DocumentIDs {
		data, err := r.ExchangeService.GetDocumentByID(ctx, v)
		if err != nil {
			return nil, nil
		}

		result = append(result, new(public_models.Document).FromEntity(data))
	}

	return result, nil
}

// Images is the resolver for the images field.
func (r *propertyResolver) Images(ctx context.Context, obj *public_models.Property) ([]*public_models.Image, error) {
	result := make([]*public_models.Image, 0, len(obj.ImageIDs))

	for _, v := range obj.ImageIDs {
		data, err := r.ExchangeService.GetImageByID(ctx, v)
		if err != nil {
			return nil, nil
		}

		result = append(result, new(public_models.Image).FromEntity(data))
	}

	return result, nil
}

// Properties is the resolver for the properties field.
func (r *queryResolver) Properties(ctx context.Context, ids []string, start *int, limit *int, sort *public_models.Sort, search *string, filter *public_models.PropertyFilter) (*public_models.PropertyConnection, error) {
	propertyFilter := &estate_entity.PropertyFilter{
		Keyword:  search,
		Statuses: []estate_entity.PropertyStatus{estate_entity.PropertyStatusPublished},
	}
	if filter != nil {
		if filter.Deal != nil {
			propertyFilter.Deal = (*estate_entity.Deal)(filter.Deal)
		}

		if filter.Type != nil {
			propertyFilter.Type = (*estate_entity.PropertyType)(filter.Type)
		}

		if filter.SubType != nil {
			propertyFilter.SubType = (*estate_entity.PropertySubType)(filter.SubType)
		}

		propertyFilter.FromDeveloper = filter.FromDeveloper
		propertyFilter.ComplexID = filter.ComplexID
		propertyFilter.VillageID = filter.VillageID
		propertyFilter.IsHot = filter.IsHot

		propertyFilter.MinRooms = filter.MinRooms
		propertyFilter.MaxRooms = filter.MaxRooms

		propertyFilter.MinPrice = filter.MinPrice
		propertyFilter.MaxPrice = filter.MaxPrice
		propertyFilter.MinPricePerMeter = filter.MinPricePerMeter
		propertyFilter.MaxPricePerMeter = filter.MaxPricePerMeter
		propertyFilter.MinPricePerAr = filter.MinPricePerAr
		propertyFilter.MaxPricePerAr = filter.MaxPricePerAr
		propertyFilter.MinArea = filter.MinArea
		propertyFilter.MaxArea = filter.MaxArea
		propertyFilter.MinLandArea = filter.MinLandArea
		propertyFilter.MaxLandArea = filter.MaxLandArea
		propertyFilter.IsReady = filter.IsReady
		propertyFilter.InCity = filter.InCity
		propertyFilter.MinCityDistance = filter.MinCityDistance
		propertyFilter.MaxCityDistance = filter.MaxCityDistance

		propertyFilter.WithPhotos = filter.WithPhotos
	}

	data, total, err := r.EstateService.SearchProperties(ctx, start, limit, estate_entity.PropertySortDefault, propertyFilter)
	if err != nil {
		return nil, err
	}

	var nodes []*public_models.Property
	for _, v := range data {
		nodes = append(nodes, new(public_models.Property).FromEntity(v))
	}

	return &public_models.PropertyConnection{
		TotalCount: total,
		Nodes:      nodes,
		PageInfo:   &public_models.PageInfo{},
	}, nil
}

// Property is the resolver for the property field.
func (r *queryResolver) Property(ctx context.Context, id string) (*public_models.Property, error) {
	data, err := r.EstateService.GetPropertyByID(ctx, id)
	if err != nil {
		return nil, err
	}

	return new(public_models.Property).FromEntity(data), nil
}

// Property returns public_gateway.PropertyResolver implementation.
func (r *Resolver) Property() public_gateway.PropertyResolver { return &propertyResolver{r} }

type propertyResolver struct{ *Resolver }
